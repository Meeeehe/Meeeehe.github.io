<!DOCTYPE html>
<html lang="en">

<head>
    <title>Three.js CSS3D - Periodic Table</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link type="text/css" rel="stylesheet" href="assets/css/periodictable.css">
</head>

<body>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> CSS3D - Periodic Table.
    </div>
    <div id="container"></div>
    <div id="menu">
        <button id="table">TABLE</button>
        <button id="sphere">SPHERE</button>
        <button id="helix">HELIX</button>
        <button id="grid">GRID</button>
    </div>

    <script type="module">
        import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js";
        import { TWEEN } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/libs/tween.module.min.js";
        import { TrackballControls } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/TrackballControls.js";
        import { CSS3DRenderer, CSS3DObject } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/renderers/CSS3DRenderer.js";

        const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSsT5dAcMPhrHo8nGg32Si8Y8Qev19GtktdzZ8Rec334dUiy6Nf2YOP8TJuqOOc-Moyj7UsGuJDfkwG/pub?output=csv";

        const CONFIG = {
            table: { columns: 20, rowSpacing: 180, columnSpacing: 140 },
            helix: { radius: 800, verticalSpacing: 20, turns: 6 },
            grid: { columns: 5, rows: 4, layers: 10, columnSpacing: 200, rowSpacing: 150, layerSpacing: 400 },
        };

        let camera, scene, renderer, controls;
        const objects = [];
        const targets = { table: [], sphere: [], helix: [], grid: [] };

        init();
        animate();

        async function fetchSheetData() {
            try {
                const response = await fetch(SHEET_URL);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const csvText = await response.text();
                return csvText.split("\n").map(row => row.match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g)?.map(cell => cell.replace(/^"|"$/g, "")) || []);
            } catch (err) {
                console.error("Failed to fetch data:", err);
                return [];
            }
        }

        function getNetWorthColor(netWorth) {
            const cleanedNetWorth = netWorth.replace(/[^0-9.]/g, "");
            const value = parseFloat(cleanedNetWorth);
            if (isNaN(value)) return "rgba(127, 127, 127, 0.7)";
            if (value < 100000) return "rgba(255, 0, 0, 0.7)";
            if (value <= 200000) return "rgba(255, 165, 0, 0.7)";
            return "rgba(0, 128, 0, 0.7)";
        }

        function createTileElement(name, photo, age, country, interest, netWorth) {
            const element = document.createElement("div");
            element.className = "element";
            element.style.cssText = `background-color: ${getNetWorthColor(netWorth)};`;

            const topRow = `
                <div class="top-row">
                    <div class="country">${country}</div>
                    <div class="age">${age}</div>
                </div>`;
            const img = `<img src="${photo}" alt="${name}" class="photo">`;
            const details = `
                <div class="name">${name}</div>
                <div class="interest">${interest}</div>`;

            element.innerHTML = topRow + img + details;
            return element;
        }

        async function initializePeriodicTable() {
            const rows = await fetchSheetData();
            rows.shift(); // Remove header row

            rows.forEach((row, i) => {
                if (row.length < 6) return;
                const [name, photo, age, country, interest, netWorth] = row;

                const element = createTileElement(name, photo, age, country, interest, netWorth);
                const objectCSS = new CSS3DObject(element);
                objectCSS.position.set(Math.random() * 4000 - 2000, Math.random() * 4000 - 2000, Math.random() * 4000 - 2000);
                scene.add(objectCSS);
                objects.push(objectCSS);

                // TABLE target position
                const { columns, rowSpacing, columnSpacing } = CONFIG.table;
                const tableTarget = new THREE.Object3D();
                tableTarget.position.set(
                    (i % columns) * columnSpacing - (columns * columnSpacing) / 2,
                    -Math.floor(i / columns) * rowSpacing + 900,
                    0
                );
                targets.table.push(tableTarget);

                // SPHERE target position
                const phi = Math.acos(-1 + (2 * i) / rows.length);
                const theta = Math.sqrt(rows.length * Math.PI) * phi;
                const sphereTarget = new THREE.Object3D();
                sphereTarget.position.setFromSphericalCoords(800, phi, theta);
                targets.sphere.push(sphereTarget);

                // DOUBLE HELIX target position
                const { radius, verticalSpacing, turns } = CONFIG.helix;
                const angleStep = (2 * Math.PI * turns) / rows.length;
                const thetaDoubleHelix = i * angleStep;
                const yDoubleHelix = i * verticalSpacing - (rows.length * verticalSpacing) / 2;
                const helixTarget = new THREE.Object3D();
                helixTarget.position.set(
                    radius * Math.cos(thetaDoubleHelix) * (i % 2 === 0 ? 1 : -1),
                    yDoubleHelix,
                    radius * Math.sin(thetaDoubleHelix)
                );
                targets.helix.push(helixTarget);

                // GRID target position
                const { columns: gCols, rows: gRows, layers: gLayers, columnSpacing: gColSpacing, rowSpacing: gRowSpacing, layerSpacing: gLayerSpacing } = CONFIG.grid;
                const gridTarget = new THREE.Object3D();
                gridTarget.position.set(
                    (i % gCols) * gColSpacing - (gCols * gColSpacing) / 2,
                    -Math.floor(i / gCols) % gRows * gRowSpacing + 300,
                    Math.floor(i / (gCols * gRows)) * gLayerSpacing - (gLayers * gLayerSpacing) / 2
                );
                targets.grid.push(gridTarget);
            });

            transform(targets.table, 2000);
        }

        function init() {
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 3000;

            scene = new THREE.Scene();

            renderer = new CSS3DRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById("container").appendChild(renderer.domElement);

            controls = new TrackballControls(camera, renderer.domElement);
            controls.minDistance = 500;
            controls.maxDistance = 6000;
            controls.addEventListener("change", render);

            initializePeriodicTable();

            document.getElementById("table").addEventListener("click", () => transform(targets.table, 2000));
            document.getElementById("sphere").addEventListener("click", () => transform(targets.sphere, 2000));
            document.getElementById("helix").addEventListener("click", () => transform(targets.helix, 2000));
            document.getElementById("grid").addEventListener("click", () => transform(targets.grid, 2000));

            window.addEventListener("resize", onWindowResize);
        }

        function transform(targets, duration) {
            TWEEN.removeAll();
            objects.forEach((object, i) => {
                const target = targets[i];
                if (!target) return;

                new TWEEN.Tween(object.position)
                    .to(target.position, duration)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();

                new TWEEN.Tween(object.rotation)
                    .to(target.rotation, duration)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();
            });

            new TWEEN.Tween(this).to({}, duration).onUpdate(render).start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
        }

        function render() {
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
